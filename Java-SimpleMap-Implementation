# Project Description
This is a simple implementation of a map.
There are four classes which are Graph, Road, Town, and TownGraphManager.
There are also other classes that are provided to run this program, but only these four classes are published since the purpose is to show work that I've done.

Graph class is the data structure of Town and Road elements.
Road class is a data element class for roads of a map.
Town class is a data element class for towns of a map.
TownGraphManager class is a data manager class that holds an object of the Graph class.

Testing codes are also provided at the end.

The followings are implmentations of each class:

# Graph Class

import java.util.*;
/**
 * This class is a data structure of town and road elements.
 * @author Jiheon Kim
 */
public class Graph implements GraphInterface<Town, Road> {
	private Set<Town> towns;
	private Set<Road> roads;
	private HashMap<Town, LinkedHashSet<Town>> townMapping;
	private HashMap<Town, LinkedHashSet<Road>> roadMapping;

	/**
	 * A constructor.
	 */
	public Graph() {
		this.townMapping = new HashMap<Town, LinkedHashSet<Town>>();
		this.roadMapping = new HashMap<Town, LinkedHashSet<Road>>();
		this.towns = new HashSet<Town>();
		this.roads = new HashSet<Road>();
	}

	/**
	 * A method that returns an edge connecting source vertex to target vertex if such vertices and edge exist in this graph.
	 * @param source
	 * @param destination
	 * @return true if such vertices and edge exist in this graph, false otherwise.
	 */
	public Road getEdge(Town source, Town destination) {
		for(Road r : roads) {
			if((r.getSource().equals(source) || r.getSource().equals(destination)) &&
				(r.getDestination().equals(destination) || r.getDestination().equals(source))) {
				return r;
			}
		}
		return null;
	}
	
	/**
	 * A method that creates a new edge in this graph.
	 * @param source
	 * @param destination
	 * @param weight
	 * @param name
	 * @return r - new edge
	 */
	public Road addEdge(Town source, Town destination, int weight, String name) throws IllegalArgumentException, NullPointerException {
		Road r = new Road(source, destination, weight, name);
		if(!containsVertex(source)) {
			throw new IllegalArgumentException();
		}
		else if(source == null || destination == null) {
			throw new NullPointerException();
		}
		roads.add(r);
		roadMapping.get(source).add(r);
		roadMapping.get(destination).add(r);
		townMapping.get(source).add(destination);
		townMapping.get(destination).add(source);
		return r;
	}
	
	/**
	 * A method that removes an edge going from source to destination if such vertices and edge exist in this graph.
	 * @param source
	 * @param destination
	 * @param weight
	 * @param name
	 * @return the removed edge, null if unsuccessful.
	 */
	public Road removeEdge(Town source, Town destination, int weight, String name) {
		Road r = new Road(source, destination, weight, name);
			if(r.getWeight() >= 0 && r.getName() != null) {
				roads.remove(r);
				roadMapping.get(source).remove(r);
				roadMapping.get(destination).remove(r);
				townMapping.get(source).remove(destination);
				townMapping.get(destination).remove(source);
				return r;
			}
		return null;
	}
	
	/**
	 * A method that returns true if this graph contains an edge going from the source to destination.
	 * @param source
	 * @param destination
	 * @return true if this graph contains an edge going from the source to destination, false otherwise.
	 */
	public boolean containsEdge(Town source, Town destination) {
		if(getEdge(source, destination) != null) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method that returns a set of the vertices present in this graph.
	 * @return a set of the vertices
	 */
	public Set<Town> vertexSet(){
		return townMapping.keySet();
	}
	
	/**
	 * A method that adds the specified vertex to this graph if not already present.
	 * @param town
	 * @return true if successfully added, false otherwise.
	 */
	public boolean addVertex(Town town) throws NullPointerException {
		LinkedHashSet<Road> road = new LinkedHashSet<Road>();
		if(town == null) {
			throw new NullPointerException();
		}
		if(!townMapping.containsKey(town)) {
			townMapping.put(town, town.getAdjacentTowns());
			roadMapping.put(town, road);
			return true;
		}
		return false;
	}
	
	/**
	 * A method that returns true if this graph contains the specified vertex.
	 * @param town
	 * @return true if this graph contians the specified vertex, false otherwise.
	 */
	public boolean containsVertex(Town town) {
		if(townMapping.containsKey(town)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method that returns a set of edges present in this graph.
	 * @return roads
	 */
	public Set<Road> edgeSet() {
		return roads;
	}
	
	/**
	 * A method that returns a set of all edges touching the specified vertex.
	 * @param town
	 * @return a set of all edges touching the specified vertex.
	 */
	public Set<Road> edgesOf(Town town) throws IllegalArgumentException, NullPointerException {
		if(!roadMapping.containsKey(town)) {
			throw new IllegalArgumentException();
		}
		else if(town == null) {
			throw new NullPointerException();
		}
		return roadMapping.get(town);
	}
	
	/**
	 * A method that removes the specified vertex from this graph including all its touching edges if present.
	 * @param town
	 * @return true if succssful, false otherwise.
	 */
	public boolean removeVertex(Town town) {
		if(townMapping.containsKey(town)) {
			 for(Town t : towns) {
				 roadMapping.get(t).removeAll(roadMapping.get(town));
			 }
			 townMapping.remove(town);
			 roadMapping.remove(town);
			 return true;
		}
		return false;
	}
	
	public HashMap<Town, LinkedHashSet<Road>> getRoadMapping() {
		return roadMapping;
	}
	
	private ArrayList<Town> endpoints;
	private Town[] visitedEndpoints;
	private int[] roadWeights;
	/**
	 * A method to find the shortest path from source to destination; it uses the Dijkstra's algorithm.
	 * @param source
	 * @param destination
	 * @return an ArrayList of Strings that describe the path from source to destination.
	 */
	public ArrayList<String> shortestPath(Town source, Town destination) {
		dijkstraShortestPath(source);
		Town t = destination;
		ArrayList<Integer> distance = new ArrayList<Integer>();
		ArrayList<String> town = new ArrayList<String>();
		ArrayList<Town> temp = new ArrayList<Town>();
		ArrayList<String> road = new ArrayList<String>();
		ArrayList<String> result = new ArrayList<String>();
		if(visitedEndpoints[endpoints.indexOf(t)] != null) {
			while(!t.equals(source)) {
				town.add(t.toString());
				temp.add(t);
				t = visitedEndpoints[endpoints.indexOf(t)];
			}
		}
		town.add(source.toString());
		temp.add(source);
		Collections.reverse(town);
		Collections.reverse(temp);
		for(int i = 0, p = 1; i < town.size(); i++, p++) {
			if(p == town.size()) {
				break;
			}
			road.add((getEdge(temp.get(i), temp.get(p)).toString()));
			distance.add((getEdge(temp.get(i), temp.get(p)).getWeight()));
		}
		for(int i = 0; i < town.size()-1; i++) {
			String data = "";
			data += town.get(i) + " via ";
			data += road.get(i) + " to ";
			data += town.get(i+1) + " ";
			data += distance.get(i) + " mi";
			result.add(data);
		}
		return result;
	}
	
	/**
	 * A method to be used by the shortestPath method to find the shortest path.
	 * @param source
	 */
	public void dijkstraShortestPath(Town source) {
		int size = vertexSet().size();
		endpoints = new ArrayList<Town>();
		roadWeights = new int[size];
		visitedEndpoints = new Town[size];
		for(int i = 0; i < roadWeights.length; i++) {
			roadWeights[i] = Integer.MAX_VALUE;
		}
		ArrayList<Town> settled = new ArrayList<Town>();
		ArrayList<Town> unsettled = new ArrayList<Town>();
		for(Town t : vertexSet()) {
			endpoints.add(t);
			unsettled.add(t);
		}
		roadWeights[endpoints.indexOf(source)] = 0;
		Town startingPoint;
		while(!unsettled.isEmpty()) {
			int shortest = endpoints.indexOf(unsettled.get(0));
			for(int i = 0; i < size; i++) {
				if(!settled.contains(endpoints.get(i)) && (roadWeights[i] < roadWeights[shortest])) {
					shortest = i;
				}
			}
			startingPoint = endpoints.get(shortest);
			calculateMinimumDistance(unsettled, startingPoint, source);
			settled.add(startingPoint);
			unsettled.remove(startingPoint);
		}
	}
	
	/**
	 * A method to be called by the dijkstra's algorithm method; it calculates the minimum distance (weight).
	 */
	private void calculateMinimumDistance(ArrayList<Town> unsettled, Town evaluationTown, Town source) {
		Town current;
		for(Town t : townMapping.get(evaluationTown)) {
			if(unsettled.contains(t)) {
				int i = endpoints.indexOf(t);
				Town previous = visitedEndpoints[i];
				if(endpoints.get(i) != source) {
					visitedEndpoints[i] = evaluationTown;
				}
				int totalDistance = 0;
				current = t;
				while(!current.equals(source)) {
					totalDistance += getEdge(visitedEndpoints[endpoints.indexOf(current)], current).getWeight();
					current = visitedEndpoints[endpoints.indexOf(current)];
				}
				if(totalDistance < roadWeights[i]) {
					roadWeights[i] = totalDistance;
					visitedEndpoints[i] = evaluationTown;
				}
				else {
					visitedEndpoints[i] = previous;
				}
			}
		}
	}
}

# Road Class

/**
 * This class is a data element class for roads of a graph.
 * @author Jiheon Kim
 */
public class Road implements Comparable<Road> {
	private Town endpointA, endpointB;
	private int distance;
	private String name;
	
	/**
	 * A constructor.
	 * @param source
	 * @param destination
	 * @param weight
	 * @param name
	 */
	public Road(Town source, Town destination, int weight, String name) {
		this.endpointA = source;
		this.endpointB = destination;
		this.distance = weight;
		this.name = name;
	}
	
	/**
	 * A constructor with weight preset at 1.
	 * @param source
	 * @param destination
	 * @param name
	 */
	public Road(Town source, Town destination, String name) {
		this.endpointA = source;
		this.endpointB = destination;
		this.name = name;
		this.distance = 1;
	}
	
	/**
	 * A getter for source.
	 * @return endpointA
	 */
	public Town getSource() {
		return endpointA;
	}
	
	/**
	 * A getter for destination.
	 * @return endpointB
	 */
	public Town getDestination() {
		return endpointB;
	}
	
	/**
	 * A getter for road name.
	 * @return name
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * A getter for road distance.
	 * @return distance
	 */
	public int getWeight() {
		return distance;
	}
	
	/**
	 * A method that returns true if the edge contains the given town.
	 * @param town
	 * @return true if the edge contains the given town, false otherwise.
	 */
	public boolean contains(Town town) {
		if(endpointA.equals(town) || endpointB.equals(town)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method that returns true if each of the ends of the road is the same as the ends of this road.
	 * @return true if each of the ends of the road is the same as the ends of this road, false otherwise.
	 */
	@Override
	public boolean equals(Object obj) {
		Road r = (Road) obj;
		if(this == r) {
			return true;
		}
		else if(endpointA.equals(r.getSource()) || endpointA.equals(r.getDestination()) && endpointB.equals(r.getDestination()) || endpointB.equals(r.getSource())) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method to compare roads.
	 * @return 0 if same, 1 otherwise.
	 */
	public int compareTo(Road o) {
		return name.compareTo(o.getName());
	}
	
	/**
	 * A hashing method.
	 */
	@Override
	public int hashCode() {
		return name.hashCode();
	}
	
	/**
	 * A method to display the name of the road.
	 * @return name
	 */
	@Override
	public String toString() {
		return name;
	}
}

# Town Class

import java.util.LinkedHashSet;

/**
 * This class is a data element class for towns of a graph.
 * @author Jiheon Kim
 */
public class Town implements Comparable<Town> {
	private String name;
	private LinkedHashSet<Town> adjacent;
	
	/**
	 * A constructor.
	 * @param name
	 */
	public Town(String name) {
		this.name = name;
		this.adjacent = new LinkedHashSet<Town>();
	}
	
	/**
	 * A copy constructor.
	 * @param templateTown
	 */
	public Town(Town templateTown) {
		this.name = templateTown.getName();
		this.adjacent = templateTown.getAdjacentTowns();
	}
	
	/**
	 * A getter for town names.
	 * @return
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * A getter for a set of adjacent towns.
	 * @return adjacentTownSet
	 */
	public LinkedHashSet<Town> getAdjacentTowns() {
		return adjacent;
	}
	
	/**
	 * A method to determine whether two towns are the same.
	 * @return true if same, false otherwise.
	 */
	@Override
	public boolean equals(Object obj) {
		Town t = (Town) obj;
		if(this.compareTo(t) == 0) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A hashing method.
	 */
	@Override
	public int hashCode() {
		return name.hashCode();
	}
	
	/**
	 * A method to compare towns.
	 */
	@Override
	public int compareTo(Town o) {
		return name.compareTo(o.getName());
	}
	
	/**
	 * A method to display town names.
	 * @return name
	 */
	public String toString() {
		return name;
	}
}

# TownGraphManager Class

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
/**
 * This class is a data manager class that will hold an object of Graph class
 * @author Jiheon Kim
 */
public class TownGraphManager implements TownGraphManagerInterface {
	Graph g;
	
	/**
	 * A constructor
	 */
	TownGraphManager() {
		g = new Graph();
	}
	
	/**
	 * A method that adds a road with two towns and a road name.
	 * @param source
	 * @param destination
	 * @param weight
	 * @param name
	 * @return true if successful, false otherwise.
	 */
	public boolean addRoad(String source, String destination, int weight, String name) {
		Town endpointA = new Town(source);
		Town endpointB = new Town(destination);
		if(g.addEdge(endpointA, endpointB, weight, name) != null) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method that returns the name of the road that both towns are connected through.
	 * @param source
	 * @param destination
	 * @return name of road if the two towns are in the same road, null otherwise.
	 */
	public String getRoad(String source, String destination) {
		Town endpointA = new Town(source);
		Town endpointB = new Town(destination);
		for(Road r : g.getRoadMapping().get(endpointA)) {
			if((r.getSource().equals(endpointA) || r.getSource().equals(endpointB)) &&
					(r.getDestination().equals(endpointB) || r.getDestination().equals(endpointA))) {
				return r.toString();
				}
			}
		return null;
	}
	
	/**
	 * A method to add a town to the graph.
	 * @param name
	 * @return true if successful, false otherwise.
	 */
	public boolean addTown(String name) {
		Town t = new Town(name);
		if(g.addVertex(t)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method to get a town with a given name.
	 * @param name
	 * @return town
	 */
	public Town getTown(String name) {
		Town t = new Town(name);
		if(t.getName().equals(name)) {
			return t;
		}
		else {
			return null;
		}
	}
	
	/**
	 * A method that determines if a town is already in the graph.
	 * @param name
	 * @return true if found, false otherwise.
	 */
	public boolean containsTown(String name) {
		Town t = new Town(name);
		if(g.containsVertex(t)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method to determine if a road is in the graph.
	 * @param source
	 * @param destination
	 * @return true if found, false otherwise.
	 */
	public boolean containsRoadConnection(String source, String destination) {
		Town endpointA = new Town(source);
		Town endpointB = new Town(destination);
		HashSet<Road> roads;
		if(g.getRoadMapping().get(endpointA).size() < g.getRoadMapping().get(endpointB).size()) {
			roads = g.getRoadMapping().get(endpointA);
		}
		else {
			roads = g.getRoadMapping().get(endpointB);
		}
		for(Road r : roads) {
			if(r.contains(endpointA) && r.contains(endpointB)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * A method that creates an ArrayList of all road titles in sorted order by road name.
	 * @return roads
	 */
	public ArrayList<String> allRoads() {
		ArrayList<String> roads = new ArrayList<String>();
		for(Road r : g.edgeSet()) {
			roads.add(r.getName());
		}
		Collections.sort(roads);
		return roads;
	}
	
	/**
	 * A method that deletes a road from the graph.
	 * @param source
	 * @param destination
	 * @param name
	 * @return true if successful, false otherwise.
	 */
	public boolean deleteRoadConnection(String source, String destination, String name) {
		Town endpointA = new Town(source);
		Town endpointB = new Town(destination);
		if(g.removeEdge(endpointA, endpointB, 0, name) != null) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method to delete a town from the graph.
	 * @param name
	 * @return true if successful, false otherwise.
	 */
	public boolean deleteTown(String name) {
		Town t = new Town(name);
		if(g.removeVertex(t)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * A method that creates an ArrayList of all towns in alphabetical order.
	 * @return towns
	 */
	public ArrayList<String> allTowns() {
		ArrayList<String> towns = new ArrayList<String>();
		for(Town t : g.vertexSet()) {
			towns.add(t.getName());
		}
		Collections.sort(towns);
		return towns;
	}
	
	/**
	 * A method that returns the shortest path from source to destination.
	 * @param source
	 * @param destination
	 * @return the shortest path if successful, null otherwise.
	 */
	public ArrayList<String> getPath(String source, String destination) {
		Town endpointA = new Town(source);
		Town endpointB = new Town(destination);
		ArrayList<String> path = new ArrayList<String>();
		if(g.shortestPath(endpointA, endpointB) != null) {
			path = g.shortestPath(endpointA, endpointB);
			return path;
		}
		else {
			return null;
		}
	}
	
	/**
	 * A method that reads a file and populates the graph.
	 * @param input
	 * @throws IOException
	 */
	public void populateTownGraph(File input) throws IOException {
		try {
			String str = "";
			String[] arr = {};
			String source, destination;
			BufferedReader reader = new BufferedReader(new FileReader(input));
			while((str = reader.readLine()) != null) {
				arr = str.split(";");
				source = arr[1]; destination = arr[2];
				addTown(source); 
				addTown(destination);
				addRoad(source, destination, Integer.parseInt(arr[0].split(",")[1]), arr[0].split(",")[0]);
			}
			reader.close();
		}
		catch(FileNotFoundException e) {
			e.printStackTrace();
		}
		catch(IOException e) {
			e.printStackTrace();
		}
	}
}

# Graph Test Code

import static org.junit.Assert.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.Set;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class Graph_STUDENT_Test {
	private Town[] town;
	private GraphInterface<Town, Road> graph;
	
	@Before
	public void setUp() throws Exception {
		town = new Town[8];
		graph = new Graph();
		
		for(int i = 1; i < 8; i++) {
			town[i] = new Town("Town_" + i);
			graph.addVertex(town[i]);
		}
		
		graph.addEdge(town[1], town[2], 6, "Road_1");
		graph.addEdge(town[1], town[3], 8, "Road_2");
		graph.addEdge(town[2], town[4], 2, "Road_3");
		graph.addEdge(town[3], town[5], 1, "Road_4");
		graph.addEdge(town[3], town[4], 5, "Road_5");
		graph.addEdge(town[4], town[6], 6, "Road_6");
		graph.addEdge(town[5], town[6], 7, "Road_7");
		graph.addEdge(town[5], town[7], 4, "Road_8");
		graph.addEdge(town[6], town[7], 5, "Road_9");
	}
	
	@After
	public void tearDown() throws Exception {
		graph = null;
	}
	
	@Test
	public void testGedEdge() {
		assertEquals(new Road(town[2], town[4],2, "Road_3"), graph.getEdge(town[2], town[4]));
		assertEquals(new Road(town[5], town[6],7, "Road_7"), graph.getEdge(town[5], town[6]));
		assertEquals(new Road(town[4], town[6],6, "Road_6"), graph.getEdge(town[4], town[6]));
	}
	
	@Test
	public void testAddEdge() {
		assertEquals(false, graph.containsEdge(town[1], town[4]));
		graph.addEdge(town[1], town[4], 3, "Road_10");
		assertEquals(true, graph.containsEdge(town[1], town[4]));
	}
	
	@Test
	public void testAddVertex() {
		Town t = new Town("Town_8");
		assertEquals(false, graph.containsVertex(t));
		graph.addVertex(t);
		assertEquals(true, graph.containsVertex(t));
	}
	
	@Test
	public void testContainsEdge() {
		assertEquals(true, graph.containsEdge(town[5], town[6]));
		assertEquals(true, graph.containsEdge(town[1], town[3]));
		assertEquals(false, graph.containsEdge(town[3], town[7]));
	}
	
	@Test
	public void testEdgeSet() {
		Set<Road> road = graph.edgeSet();
		ArrayList<String> roadList = new ArrayList<String>();
		for(Road r : road) {
			roadList.add(r.getName());
		}
		Collections.sort(roadList);
		assertEquals("Road_1", roadList.get(0));
		assertEquals("Road_3", roadList.get(2));
		assertEquals("Road_6", roadList.get(5));
	}
	
	@Test
	public void testEdgesOf() {
		Set<Road> road = graph.edgeSet();
		ArrayList<String> roadList = new ArrayList<String>();
		for(Road r : road) {
			roadList.add(r.getName());
		}
		Collections.sort(roadList);
		assertEquals("Road_4", roadList.get(3));
		assertEquals("Road_6", roadList.get(5));
		assertEquals("Road_8", roadList.get(7));
	}
	
	@Test
	public void testRemoveEdge() {
		assertEquals(true, graph.containsEdge(town[4], town[6]));
		graph.removeEdge(town[4], town[6], 6, "Road_6");
		assertEquals(false, graph.containsEdge(town[4], town[6]));
	}
	
	@Test
	public void testRemoveVertex() {
		assertEquals(true, graph.containsVertex(town[6]));
		graph.removeVertex(town[6]);
		assertEquals(false, graph.containsVertex(town[6]));
	}
	
	@Test
	public void testVertexSet() {
		Set<Town> road = graph.vertexSet();
		assertEquals(true, road.contains(town[3]));
		assertEquals(true, road.contains(town[5]));
	}
	
	@Test
	public void testTown_1ToTown_7() {
		String source = "Town_1", destination = "Town_7";
		Town start = null, end = null;
		Set<Town> towns = graph.vertexSet();
		Iterator<Town> iterator = towns.iterator();
		while(iterator.hasNext()) {
			Town t = iterator.next();
			if(t.getName().equals(source)) {
				start = t;
			}
			else if(t.getName().equals(destination)) {
				end = t;
			}
		}
		if(start != null && end != null) {
			ArrayList<String> path = graph.shortestPath(start, end);
			assertNotNull(path);
			assertTrue(path.size() > 0);
			assertEquals("Town_1 via Road_2 to Town_3 8 mi", path.get(0));
			assertEquals("Town_3 via Road_4 to Town_5 1 mi", path.get(1));
			assertEquals("Town_5 via Road_8 to Town_7 4 mi", path.get(2));
		}
		else {
			fail("Failed.");
		}
	}
}

# Road Test Class

import static org.junit.Assert.*;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class Road_STUDENT_Test {
	private Town[] town;
	private Road road_1, road_2, road_3, road_4;
	
	@Before
	public void setUp() throws Exception {
		town = new Town[5];
		for(int i = 1; i < 5; i++) {
			town[i] = new Town("Town_" + i);
		}
		road_1 = new Road(town[1], town[2], 3, "Road_1");
		road_2 = new Road(town[2], town[3], 6, "Road_2");
		road_3 = new Road(town[3], town[4], 4, "Road_3");
		road_4 = new Road(town[2], town[4], 1, "Road_4");
	}
	
	@After
	public void tearDown() throws Exception {
		
	}
	
	@Test
	public void testContains() {
		assertEquals(true, road_1.contains(town[1]));
		assertEquals(false, road_2.contains(town[4]));
	}
	
	@Test
	public void testEquals() {
		assertEquals(true, town[1].equals(town[1]));
		assertEquals(false, town[4].equals(town[1]));
	}
	
	@Test
	public void testCompareTo() {
		assertEquals(0, town[2].compareTo(town[2]));
		assertEquals(1, town[3].compareTo(town[2]));
	}
}

# Town Test Code

import static org.junit.Assert.*;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class Town_STUDENT_Test {
	private Town[] town;
	
	@Before
	public void setUp() throws Exception {
		town = new Town[5];
		for(int i = 1; i < 5; i++) {
			town[i] = new Town("Town_" + i);
		}
	}
	
	@After
	public void tearDown() throws Exception {
		
	}
	
	@Test
	public void testEquals() {
		assertEquals(true, town[1].equals(town[1]));
		assertEquals(false, town[4].equals(town[1]));
	}
	
	@Test
	public void testCompareTo() {
		assertEquals(0, town[2].compareTo(town[2]));
		assertEquals(1, town[3].compareTo(town[2]));
	}
}

# TownGraphManager Test Code

import static org.junit.Assert.*;
import java.util.ArrayList;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class TownGraphManager_STUDENT_Test {
	private String[] town;
	private TownGraphManagerInterface graph;
	
	@Before
	public void setUp() throws Exception {
		town = new String[8];
		graph = new TownGraphManager();
		
		for(int i = 1; i < 8; i++) {
			town[i] = "Town_" + i;
			graph.addTown(town[i]);
		}
		
		graph.addRoad(town[1], town[2], 6, "Road_1");
		graph.addRoad(town[1], town[3], 8, "Road_2");
		graph.addRoad(town[2], town[4], 2, "Road_3");
		graph.addRoad(town[3], town[5], 1, "Road_4");
		graph.addRoad(town[3], town[4], 5, "Road_5");
		graph.addRoad(town[4], town[6], 6, "Road_6");
		graph.addRoad(town[5], town[6], 7, "Road_7");
		graph.addRoad(town[5], town[7], 4, "Road_8");
		graph.addRoad(town[6], town[7], 5, "Road_9");
	}
	
	@After
	public void tearDown() throws Exception {
		graph = null;
	}
	
	@Test
	public void testAddRoad() {
		ArrayList<String> road = graph.allRoads();
		assertEquals("Road_1", road.get(0));
		assertEquals("Road_2", road.get(1));
		assertEquals("Road_3", road.get(2));
		graph.addRoad(town[2], town[6], 8, "Road_10");
		road = graph.allRoads();
		assertEquals("Road_1", road.get(0));
		assertEquals("Road_10", road.get(1));
		assertEquals("Road_2", road.get(2));
	}
	
	@Test
	public void testGetRoad() {
		assertEquals("Road_7", graph.getRoad(town[5], town[6]));
		assertEquals("Road_4", graph.getRoad(town[3], town[5]));
		assertEquals("Road_9", graph.getRoad(town[6], town[7]));
	}
	
	@Test
	public void testContainsTown() {
		assertEquals(true, graph.containsTown("Town_5"));
		assertEquals(true, graph.containsTown("Town_7"));
		assertEquals(false, graph.containsTown("Town_9"));
	}
	
	@Test
	public void testContainsRoadConnection() {
		assertEquals(true, graph.containsRoadConnection(town[1], town[3]));
		assertEquals(true, graph.containsRoadConnection(town[4], town[6]));
		assertEquals(false, graph.containsRoadConnection(town[4], town[7]));
	}
	
	@Test
	public void testAllRoads() {
		ArrayList<String> road = graph.allRoads();
		assertEquals("Road_1", road.get(0));
		assertEquals("Road_2", road.get(1));
		assertEquals("Road_3", road.get(2));
	}
	
	@Test
	public void testDeleteRoadConnection() {
		assertEquals(true, graph.containsRoadConnection(town[1], town[3]));
		graph.deleteRoadConnection(town[1], town[3], "Road_2");
		assertEquals(false, graph.containsRoadConnection(town[1], town[3]));
	}
	
	@Test
	public void testDeleteTown() {
		assertEquals(true, graph.containsTown("Town_5"));
		graph.deleteTown(town[5]);
		assertEquals(false, graph.containsTown("Town_5"));
	}
	
	@Test
	public void testAllTowns() {
		ArrayList<String> road = graph.allTowns();
		assertEquals("Town_3", road.get(2));
		assertEquals("Town_4", road.get(3));
		assertEquals("Town_5", road.get(4));
	}
	
	@Test
	public void testGetPath() {
		ArrayList<String> path = graph.getPath(town[1], town[4]);
		assertNotNull(path);
		assertTrue(path.size() > 0);
		System.out.println(path);
		assertEquals("Town_1 via Road_1 to Town_2 6 mi", path.get(0).trim());
		assertEquals("Town_2 via Road_3 to Town_4 2 mi", path.get(1).trim());
		}	

	@Test
	public void testDisjointGraph() {
		assertEquals(false, graph.containsTown("Town_8"));
		graph.addTown("Town_8");
		ArrayList<String> path = graph.getPath(town[1], "Town_8");
		assertFalse(path.size() > 0);
	}
}
